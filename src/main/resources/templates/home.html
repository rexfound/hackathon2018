<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <style>
      body {margin:0px;padding:0px;} #mapid {height:100vh; width:100vw; display:block;}

      .leaflet-bottom.leaflet-left{
        width: 100%;
      }
      .leaflet-control-container .leaflet-timeline-controls{
        box-sizing: border-box;
        width: 100%;
        margin: 0;
        margin-bottom: 15px;
      }
    </style>
	<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
     <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin=""/>

	<script src="js/heatmap.js"></script>
    <script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"
     integrity="sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA=="
     crossorigin=""></script>
		<link rel="stylesheet" href="https://danwild.github.io/leaflet-velocity/dist/leaflet-velocity.css" />
   <script src="https://danwild.github.io/leaflet-velocity/dist/leaflet-velocity.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.17.1/moment.min.js"></script>
    <script src="js/leaflet.timeline.js"></script>
    <link rel="stylesheet" type="text/css" href="css/leaflet-openweathermap.css" />
    <script type="text/javascript" src="./js/leaflet-openweathermap.js"></script>
	<script src="js/leaflet-heatmap.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.4.8/d3.min.js"></script>
  </head>
  <body>
    <div id="mapid"></div>
    <!--The div element for the map -->
    <script src="js/vancouver.js" type="text/javascript"></script>
	<script src="js/testData.js" type="text/javascript"></script>
    <script>
  var mAttr = 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery &copy; <a href="https://www.mapbox.com/">Mapbox</a>';
  var mUrl = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}';
  var _OWM_DEFAULT_CONFIG = {opacity: 0.5, appId: '17556070bfb60252ba8bcd48fc9408d5'};

  function getColor(cartodb_id) {
    return cartodb_id % 2 == 0 ? '#800026' : '#BD0026';
  }
  
  //gets the color for a 
  function getColorFor(str) { // java String#hashCode
    var hash = 0;
    for (var i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    var red = (hash >> 24) & 0xff;
    var grn = (hash >> 16) & 0xff;
    var blu = (hash >>  8) & 0xff;
    return 'rgb(' + red + ',' + grn + ',' + blu + ')';
  } 

  function style(feature) {
    return {
      weight: 2,
      opacity: 1,
      color: 'white',
      dashArray: '3',
      fillOpacity: 0.3,
      fillColor: getColor(feature.properties.cartodb_id)
    };
  }
  
  /* To add new layers, create a layerGroup as follows*/
  /*sample layer groups*/
  var cities = L.layerGroup();
  L.marker([49.056801, -122.285042]).bindPopup('Abbotsford, Popluation ~141,397').addTo(cities);
  L.marker([49.2488, -122.9805]).bindPopup('Burnaby, Population ~232,755').addTo(cities);
  L.marker([49.2628, -122.7811]).bindPopup('Coquitlam, Population ~139,284').addTo(cities);
  L.marker([49.0952, -123.0265]).bindPopup('Delta, Population ~102,238').addTo(cities);
  L.marker([49.2827, -123.1207]).bindPopup('Vancouver, Population ~631,486').addTo(cities);
  L.marker([49.166592, -123.133568]).bindPopup('Richmond, Population ~198309').addTo(cities);
  L.marker([49.1913, -122.8490]).bindPopup('Surrey, Population ~517,887').addTo(cities);

  var geoJson = L.geoJSON(vanData,{style: style});
  
  var timeline = L.timeline(vanData);

  var lakeJson = L.geoJSON(testJson);

  var clouds = L.OWM.clouds(_OWM_DEFAULT_CONFIG);
  var cloudscls = L.OWM.cloudsClassic(_OWM_DEFAULT_CONFIG);
  var precipitation = L.OWM.precipitation(_OWM_DEFAULT_CONFIG);
  var precipitationcls = L.OWM.precipitationClassic(_OWM_DEFAULT_CONFIG);
  var rain = L.OWM.rain(_OWM_DEFAULT_CONFIG);
  var raincls = L.OWM.rainClassic(_OWM_DEFAULT_CONFIG);
  var snow = L.OWM.snow(_OWM_DEFAULT_CONFIG);
  var pressure = L.OWM.pressure(_OWM_DEFAULT_CONFIG);
  var pressurecntr = L.OWM.pressureContour(_OWM_DEFAULT_CONFIG);
  var temp = L.OWM.temperature(_OWM_DEFAULT_CONFIG);
  var wind = L.OWM.wind(_OWM_DEFAULT_CONFIG);

  /*End of sample layergroup */
  
  /*Some hardcoded testing data for heatmap*/
   var testData = {
   max: 10,
   data: [{lat: 49.056801, lng: -122.285042, count: 141397},{lat: 49.2488, lng: -122.9805, count: 232755},{lat: 49.2628, lng: -122.7811, count: 139284},
   {lat: 49.0952, lng: -123.0265, count: 102238},{lat: 49.2827, lng: -123.1207, count: 631486},{lat: 49.166592, lng: -123.133568, count: 198309}, {lat: 49.1913, lng: -122.8490, count: 517887}]
   };

  var cfg = {
  // radius should be small ONLY if scaleRadius is true (or small radius is intended)
  // if scaleRadius is false it will be the constant radius used in pixels
  "radius": 0.1,
  "maxOpacity": .5, 
  // scales the radius based on map zoom
  "scaleRadius": true, 
  // if set to false the heatmap uses the global maximum for colorization
  // if activated: uses the data maximum within the current map boundaries 
  //   (there will always be a red spot with useLocalExtremas true)
  "useLocalExtrema": true,
  // which field name in your data represents the latitude - default "lat"
  latField: 'lat',
  // which field name in your data represents the longitude - default "lng"
  lngField: 'lng',
  // which field name in your data represents the data value - default "value"
  valueField: 'count'
  };
   var heatmapLayer = new HeatmapOverlay(cfg);

  // add more layers here
  var baseLayer = L.tileLayer(mUrl, {
    attribution: mAttr,
    maxZoom: 16,
    id: 'mapbox.light',
    accessToken: 'pk.eyJ1IjoiemVoYWNrcyIsImEiOiJjam42bjh2OGIwbDFzM3dwaTh3N3NtNWRqIn0.yapaCg5pOEkYkPiskIszyQ'
  });

  var darkLayer = L.tileLayer(mUrl, {
    attribution: mAttr,
    maxZoom: 14,
    id: 'mapbox.dark',
    accessToken: 'pk.eyJ1IjoiemVoYWNrcyIsImEiOiJjam42bjh2OGIwbDFzM3dwaTh3N3NtNWRqIn0.yapaCg5pOEkYkPiskIszyQ'
  });
  
  var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18, attribution: '[Map provided by OSM]' });

  var mapConfig = {
    center: [49.2827, -123.1207],
    zoom: 10,
    layers: [baseLayer]
  };


  var mymap = L.map('mapid', mapConfig);


  var myStyle = {
      "color": "#ff7800",
      "weight": 5,
      "opacity": 0.65
  };

  function mapDraw(csv, map, nearest, nearestWind){
    var pointdata = csv;

    var svg = d3.select("#mymap").select("svg");
    var g = svg.append("g").attr("class", "leaflet-zoom-hide");


    var voronoi = d3.geom.voronoi()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; });
     update();

	function getScaleColor(value, tempLookUp) {
		return tempLookUp[-1 * parseInt((value - 45)/5)];
	}
	 
	function getComputedColor(value, max, min) {
	  var mid = (max - min)/2;
	  var diffMid = max - mid;
	  
	  var red = 0;
	  var blue = 0;
	  
	  var ratio = (max - value) / diffMid;
	  red = parseInt(256 * (1-ratio));
      
	  var ratio = (value - min) / diffMid;
	  blue = parseInt(256 * (1-ratio));
	  
	  return "rgb(" + red + "," + "20," + blue + ")";
	}
	
	function voronoiStyle(array) {
	   return {
		 "weight": 0.5,
		 "opacity": 0.8,
		 "fillOpacity" :0.3,
		 "color": array.point.TEMP_COLOR
	   }
	 };
	 
	function voronoiStyleWind(array) {
	   return {
		 "weight": 0.3,
		 "opacity": 0.8,
		 "color": array.point.WIND_COLOR
	   }
	 };
	
	
    function update() {
      var positions = [];
	  
	  var maxTemp = -1;
	  var minTemp = 999;
	  var minWind = 999;
	  var maxWind = -1;
	  
	  pointdata.forEach(function(d) {
		var tempTemp = parseFloat(d.TEMP);
		if (tempTemp > maxTemp) maxTemp = tempTemp;
		if (tempTemp < minTemp) minTemp = tempTemp;
		var tempWind = parseFloat(d.WIND_SPD);
		if (tempWind > maxWind) maxWind = tempWind;
		if (tempWind < minWind) minWind = tempWind;
	  });
	  
	  

	 
		var tempLookUp = ['rgb(173,0,0)','rgb(220,0,0)','rgb(254,15,0)','rgb(254,71,0)','rgb(254,131,0)','rgb(254,187,0)','rgb(254,243,0)','rgb(211,254,43)','rgb(155,254,99)','rgb(95,253,159)','rgb(39,253,215)','rgb(0,233,254)','rgb(0,163,254)','rgb(0,89,254)','rgb(0,19,254)','rgb(0,0,220)','rgb(0,0,173)'];
		console.log(tempLookUp);
		
	  
      pointdata.forEach(function(d) {

		if (d.LAT != null && d.LON != null && d.TEMP < 200) {
			positions.push({x:d.LAT, y:d.LON, TEMP:d.TEMP, WIND_SPD:d.WIND_SPD, TEMP_COLOR:getScaleColor(d.TEMP, tempLookUp), WIND_COLOR:getComputedColor(d.WIND_SPD,minWind,maxWind)});
		}
      });
      
      console.log(positions);
      var polygons = voronoi(positions);
      polygons.forEach(function(v) { L.polygon(v, voronoiStyle(v)).bindPopup("Temperature: " + v.point.TEMP).addTo(nearest);});
      polygons.forEach(function(v) { L.polygon(v, voronoiStyleWind(v)).addTo(nearestWind);});
    }
  }
  
    /*Adding the layerGroup here allows the user to control what shows up on the overlay*/
    
  var nearestTemp = L.layerGroup();
  var nearestWind = L.layerGroup();
  var windVel = L.layerGroup();
  
  var overlays = {
    "Cities": cities,
    "Geo": geoJson,
    "Lakes": lakeJson,
    "Clouds": clouds,
    "Rain": rain,
    "Pressure": pressurecntr,
    "Temperature": temp,
    "Heatmap" : heatmapLayer,
    "Nearest Neighbour Temp": nearestTemp,
    "Wind Velocity Animated - mock": windVel
  };

  d3.json('/api/getWeatherData', function(json){
    mapDraw(json, mymap, nearestTemp, nearestWind);
  });

  $.getJSON('/js/wind-global.json', function (data) {
     var velocityLayer = L.velocityLayer({
       displayValues: true,
       displayOptions: {
         velocityType: 'GBR Wind',
         displayPosition: 'bottomleft',
         displayEmptyString: 'No wind data'
       },
       data: data,
       maxVelocity: 10
     });

   velocityLayer.addTo(windVel);
 });
  
  var baseLayers = {
    "Grey Basic": baseLayer,
    "Dark theme": darkLayer,
    "OSM Basic": osm
  };

  /*L.geoJSON(vancouverData).addTo(mymap);*/
  //console.log(vancouverData);
  L.control.layers(baseLayers,overlays).addTo(mymap);

  heatmapLayer.setData(testData);

    </script>
  </body>
</html>
